<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫秀学习日志</title>
  <icon>http://fengxiu.club/icon.png</icon>
  <subtitle>枫秀学习日志</subtitle>
  <link href="http://fengxiu.club/atom.xml" rel="self"/>
  
  <link href="http://fengxiu.club/"/>
  <updated>2022-12-07T11:16:38.000Z</updated>
  <id>http://fengxiu.club/</id>
  
  <author>
    <name>枫秀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>post</title>
    <link href="http://fengxiu.club/archives/51727.html"/>
    <id>http://fengxiu.club/archives/51727.html</id>
    <published>2022-12-07T11:16:38.000Z</published>
    <updated>2022-12-07T11:16:38.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;翻译自&lt;a href=&quot;https://people.apache.org/~fhanik/kiss.html&quot;&gt;https://people.apache.org/~fhanik/kiss.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;KISS代表什么？&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="kiss" scheme="http://fengxiu.club/tags/kiss/"/>
    
  </entry>
  
  <entry>
    <title>外观模式</title>
    <link href="http://fengxiu.club/archives/f7de8aa8.html"/>
    <id>http://fengxiu.club/archives/f7de8aa8.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-12-07T03:18:22.393Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h1&gt;&lt;p&gt;外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。&lt;/p&gt;
&lt;p&gt;最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://fengxiu.club/archives/f5c535ea.html"/>
    <id>http://fengxiu.club/archives/f5c535ea.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-12-07T03:18:22.393Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;p&gt;适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。&lt;/p&gt;
&lt;p&gt;在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/fengxiu/img/problem-zh-2x.png&quot; alt=&quot;problem-zh-2x&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯TEG面经：java实习岗</title>
    <link href="http://fengxiu.club/archives/52bb366.html"/>
    <id>http://fengxiu.club/archives/52bb366.html</id>
    <published>2019-04-02T10:49:22.000Z</published>
    <updated>2022-12-07T03:18:22.393Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;下面记录的是我面腾讯TEG事业群的经历&lt;/p&gt;
&lt;h2 id=&quot;腾讯一面-2019年03月13日&quot;&gt;&lt;a href=&quot;#腾讯一面-2019年03月13日&quot; class=&quot;headerlink&quot; title=&quot;腾讯一面 2019年03月13日&quot;&gt;&lt;/a&gt;腾讯一面</summary>
        
      
    
    
    
    <category term="面试" scheme="http://fengxiu.club/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里春招实习面经：java开发</title>
    <link href="http://fengxiu.club/archives/8650cc91.html"/>
    <id>http://fengxiu.club/archives/8650cc91.html</id>
    <published>2019-04-02T11:27:29.000Z</published>
    <updated>2022-12-07T03:18:22.393Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;先说一下，你们可能看到我的面经也会觉得很惊奇，为什么其他面经里面出现的问题，我这里几乎都没出现，而且面试流程也走的这么快。下面就看一下我的阿里春招面试奇葩之旅。&lt;/p&gt;
&lt;h2 id=&quot;阿里一面-2019年03月28日&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="面试" scheme="http://fengxiu.club/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Http的演进之路之六</title>
    <link href="http://fengxiu.club/archives/cd15eee9.html"/>
    <id>http://fengxiu.club/archives/cd15eee9.html</id>
    <published>2019-03-10T12:23:00.000Z</published>
    <updated>2022-12-07T03:18:22.393Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Http的演进之路之六&quot;&gt;&lt;a href=&quot;#Http的演进之路之六&quot; class=&quot;headerlink&quot; title=&quot;Http的演进之路之六&quot;&gt;&lt;/a&gt;Http的演进之路之六&lt;/h1&gt;&lt;h2 id=&quot;声明，此系列文章转载自lonnieZ-http的演进之路&quot;&gt;&lt;a href=&quot;#声明，此系列文章转载自lonnieZ-http的演进之路&quot; class=&quot;headerlink&quot; title=&quot;声明，此系列文章转载自lonnieZ http的演进之路&quot;&gt;&lt;/a&gt;声明，此系列文章转载自&lt;a href=&quot;https://www.zhihu.com/people/lonniez/activities&quot;&gt;lonnieZ http的演进之路&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;Http-x2F-2&quot;&gt;&lt;a href=&quot;#Http-x2F-2&quot; class=&quot;headerlink&quot; title=&quot;Http&amp;#x2F;2&quot;&gt;&lt;/a&gt;&lt;strong&gt;Http&amp;#x2F;2&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;鉴于SPDY的成功，HTTP&amp;#x2F;2的开发计划也呼之欲出并且众望所归的采用了SPDY作为整个方案的蓝图进行开发。由&lt;a href=&quot;http://link.zhihu.com/?target=https://www.ietf.org/&quot;&gt;IETF&lt;/a&gt;推动，Google等公司重点参与并于2015年3月公布了&lt;a href=&quot;http://link.zhihu.com/?target=http://http2.github.io/http2-spec/&quot;&gt;草案&lt;/a&gt;。其最终RFC可以参考&lt;a href=&quot;http://link.zhihu.com/?target=https://tools.ietf.org/html/rfc7540&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/fengxiu/img/pasted-266.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
    <category term="http" scheme="http://fengxiu.club/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享(CORS)</title>
    <link href="http://fengxiu.club/archives/f1718313.html"/>
    <id>http://fengxiu.club/archives/f1718313.html</id>
    <published>2019-04-29T14:54:01.000Z</published>
    <updated>2022-12-07T03:18:22.393Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;跨域资源共享(CORS)是一种机制，它使用额外的HTTP头来告诉浏览器让运行在一个origin(domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP请求。&lt;/p&gt;
&lt;p&gt;比如，站点&lt;a href=&quot;&quot;&gt;http://domain-a.com&lt;/a&gt;的某HTML页面通过&lt;code&gt;img&lt;/code&gt;的src请求&lt;a href=&quot;&quot;&gt;http://domain-b.com/image.jpg&lt;/a&gt;。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。&lt;/p&gt;
&lt;p&gt;出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
    <category term="跨域资源共享" scheme="http://fengxiu.club/tags/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    
    <category term="cors" scheme="http://fengxiu.club/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://fengxiu.club/archives/f79e4123.html"/>
    <id>http://fengxiu.club/archives/f79e4123.html</id>
    <published>2018-09-21T14:42:00.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h1&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;虚拟内存是什么、可以用来做什么&lt;/li&gt;
&lt;li&gt;基本概念介绍&lt;/li&gt;
&lt;li&gt;虚拟内存作为缓存的工具&lt;/li&gt;
&lt;li&gt;虚拟内存作为内存管理的工具&lt;/li&gt;
&lt;li&gt;虚拟内存作为内存保护的工具&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-虚拟内存是什么、功能是什么&quot;&gt;&lt;a href=&quot;#1-虚拟内存是什么、功能是什么&quot; class=&quot;headerlink&quot; title=&quot;1. 虚拟内存是什么、功能是什么&quot;&gt;&lt;/a&gt;1. 虚拟内存是什么、功能是什么&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;虚拟内存是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存&lt;/strong&gt;是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。&lt;/p&gt;
&lt;p&gt;下面是《深入立即操作系统》给出的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。&lt;/p&gt;
&lt;p&gt;虚拟内存功能是什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。&lt;/li&gt;
&lt;li&gt;它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/li&gt;
&lt;li&gt;它保护了每个进程的地址空间不被其他进程破坏。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://fengxiu.club/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://fengxiu.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="http://fengxiu.club/archives/6ebbfb41.html"/>
    <id>http://fengxiu.club/archives/6ebbfb41.html</id>
    <published>2019-06-11T14:49:58.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文翻译自:&lt;a href=&quot;http://www.linuxjournal.com/article/6345&quot;&gt;Zero Copy I: User-Mode Perspective&lt;/a&gt;&lt;br&gt;本文解释了Linux的零拷贝作用是什么，为什么它非常有用和在哪些地方可以使用该功能。&lt;/p&gt;
&lt;p&gt;到目前为止，几乎每个人都听说过在Linux下的所谓的零拷贝功能，但我经常遇到对这个主题没有完全理解的人。 正因为如此，我决定写一些文章，深入探讨这件事，希望揭开这个有用的功能。 在本文中，我们从用户应用程序的角度看待零拷贝，因此故意省略了内核级别的详细信息。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://fengxiu.club/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://fengxiu.club/tags/linux/"/>
    
    <category term="零拷贝" scheme="http://fengxiu.club/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>sql的几种连接</title>
    <link href="http://fengxiu.club/archives/527f2873.html"/>
    <id>http://fengxiu.club/archives/527f2873.html</id>
    <published>2019-03-28T17:38:33.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在Mysql中连接主要有内连接和外连接，本篇文章主要讲解这俩种连接。&lt;br&gt;表的定义和数据如下&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
        
      
    
    
    
    <category term="数据库" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库连接池大小设置</title>
    <link href="http://fengxiu.club/archives/8551d0c1.html"/>
    <id>http://fengxiu.club/archives/8551d0c1.html</id>
    <published>2019-08-28T10:09:53.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;翻译自&lt;a href=&quot;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&quot;&gt;About Pool Sizing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开发人员在配置数据库连接池的时候，经常会犯一些错误。在配置数据库连接池时，需要理解一些可能违反直觉的原则。&lt;br&gt;因此本篇文章主要介绍这些原则。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="连接池" scheme="http://fengxiu.club/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>LVS、Nginx及HAProxy工作原理简介</title>
    <link href="http://fengxiu.club/archives/3c2eb649.html"/>
    <id>http://fengxiu.club/archives/3c2eb649.html</id>
    <published>2019-07-20T12:22:32.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;当前大多数的互联网系统都使用了服务器集群技术，集群是将相同服务部署在多台服务器上构成一个集群整体对外提供服务，这些集群可以是 Web 应用服务器集群，也可以是数据库服务器集群，还可以是分布式缓存服务器集群等等。&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/fengxiu/img/640.webp&quot; alt=&quot;640&quot;&gt;&lt;br&gt;在实际应用中，在 Web服务器集群之前总会有一台负载均衡服务器，负载均衡设备的任务就是作为Web 服务器流量的入口，挑选最合适的一台 Web 服务器，将客户端的请求转发给它处理，实现客户端到真实服务端的透明转发。&lt;/p&gt;
&lt;p&gt;最近几年很火的「云计算」以及分布式架构，本质上也是将后端服务器作为计算资源、存储资源，由某台管理服务器封装成一个服务对外提供，客户端不需要关心真正提供服务的是哪台机器，在它看来，就好像它面对的是一台拥有近乎无限能力的服务器，而本质上，真正提供服务的，是后端的集群。&lt;/p&gt;</summary>
    
    
    
    <category term="架构" scheme="http://fengxiu.club/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="代理" scheme="http://fengxiu.club/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="负载均衡" scheme="http://fengxiu.club/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Zuul2：Netflix通往异步、非阻塞系统之路</title>
    <link href="http://fengxiu.club/archives/ad8701ca.html"/>
    <id>http://fengxiu.club/archives/ad8701ca.html</id>
    <published>2019-07-12T16:02:36.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c&quot;&gt;Zuul 2 : The Netflix Journey to Asynchronous, Non-Blocking Systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面在学习Spring Cloud中，了解到zuul这个应用网关，但是由于当时看到的是zuul1，使用的Servlet方式实现，所以整体性能很低。不过Netflix实际上升级了zuul，使用了netty来改造网关，也就是现在网关底层使用的是异步非阻塞的架构。下面我们就一起来拜读下他们的改造路程。&lt;br&gt;翻译如下：&lt;/p&gt;
&lt;p&gt;我们最近对我们的云网关Zuul进行了重大架构改造。Zuul2的功能与其前任相同 - 作为Netflix服务器基础设施的前门，处理来自全球所有Netflix用户的流量。它还可以路由请求，支持开发人员的测试和调试，深入了解我们的整体服务运行状况，保护Netflix免受攻击，并在AWS区域出现问题时将流量引导至其他云区域。 Zuul 2和原始版本之间的主要架构差异是Zuul2使用Netty在异步和非阻塞框架上运行。在过去几个月投入生产之后，主要优势（我们在开始这项工作时所期望的一个优势）是它为设备和Web浏览器提供了在Netflix规模上持久连接回Netflix的能力。拥有超过8300万会员，每个会员都有多个连接设备，这是一个巨大的挑战。通过与我们的云基础架构保持持久连接，我们可以实现许多有趣的产品功能和创新，减少整体设备请求，提高设备性能，更好地理解和调试客户体验。&lt;/p&gt;
&lt;p&gt;我们还希望Zuul2在延迟，吞吐量和成本方面提供弹性优势和性能改进。但正如您将在本文中了解到的那样，我们的愿望与结果不同。&lt;/p&gt;</summary>
    
    
    
    <category term="架构" scheme="http://fengxiu.club/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="zuul2" scheme="http://fengxiu.club/tags/zuul2/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎 之 锁</title>
    <link href="http://fengxiu.club/archives/31ad40b4.html"/>
    <id>http://fengxiu.club/archives/31ad40b4.html</id>
    <published>2019-03-21T15:03:03.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;开发多用户、数据库驱动的应用时，最大的一个难点是：一方面要最大成都地利用数据库的并发访问，另外一方面还要确保每个用户能以一致的方式读取和修改数据，为此就有了锁的机制，同时这也是数据库系统区别于文件系统的一个关键特性。InnoDB存储引擎较之mysql数据库的其它存储引擎在这方面技高一筹。而只有正确的了解这些锁的内部机制才能充分发挥InnoDB存储引擎在这方面的优势。本篇文章会详细介绍InnoDB存储引擎对表中数据的锁定，同时分析InnoDB存储引擎会以怎样的力度锁定数据。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
    <category term="innodb" scheme="http://fengxiu.club/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>mysql explain 详解</title>
    <link href="http://fengxiu.club/archives/dd6beb0a.html"/>
    <id>http://fengxiu.club/archives/dd6beb0a.html</id>
    <published>2019-03-26T19:57:28.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;在看《高性能mysql》这本书的时候，经常看到explain这个命令。所以希望总结一下这个命令的一些知识点。此外，我们为了能够在数据库运行过程中去优化，就会开启慢查询日志，而慢查询日志记录一些执行时间比较久的SQL语句，但是找出这些SQL语句并不意味着完事了。我们需要分析为什么这条sql执行的慢，也就是找出具体的原因。这时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。（QEP：sql生成一个执行计划query Execution plan）&lt;/p&gt;
&lt;p&gt;首先我们看看这个命令输出的具体格式，然后分别的解释其中每列代表的意思,如果执行这条sql语句&lt;code&gt;explain  select * from film&lt;/code&gt;,输出的内容如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;select_type&lt;/th&gt;
&lt;th&gt;table&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;possible_keys&lt;/th&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;key_len&lt;/th&gt;
&lt;th&gt;ref&lt;/th&gt;
&lt;th&gt;rows&lt;/th&gt;
&lt;th&gt;filtered&lt;/th&gt;
&lt;th&gt;Extras&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;SIMPLE&lt;/td&gt;
&lt;td&gt;film&lt;/td&gt;
&lt;td&gt;ALL&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;以上就是explain命令打印出来的信息，先对这些字段进行一个简介，有个整体的感知，然后在分别详细介绍每一个字段&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;在一个大的查询语句中，每个SELECT关键字都对应一个唯一的id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_type&lt;/td&gt;
&lt;td&gt;SELECT关键字对应的查询的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;表名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;匹配的分区信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;针对单表的访问方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;可能使用到的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;实际使用的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;key_len&lt;/td&gt;
&lt;td&gt;实时使用的索引长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;当使用索引列等值查询时，与索引列进行等值匹配的对象信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;预估的需要读取的记录条数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;针对预估的需要读取的记录，经过搜索条件过滤后剩余记录条数的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;extra&lt;/td&gt;
&lt;td&gt;一些额外信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
    <category term="mysql" scheme="http://fengxiu.club/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 管道化(pipeline)</title>
    <link href="http://fengxiu.club/archives/6fbc205f.html"/>
    <id>http://fengxiu.club/archives/6fbc205f.html</id>
    <published>2019-03-10T14:46:00.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是http管道化&quot;&gt;&lt;a href=&quot;#什么是http管道化&quot; class=&quot;headerlink&quot; title=&quot;什么是http管道化&quot;&gt;&lt;/a&gt;什么是http管道化&lt;/h2&gt;&lt;p&gt;pipeline机制是在&lt;strong&gt;一条connection&lt;/strong&gt;上多个http request不需要等待response就可以连续发送的技术。之前的request请求需要等待response返回后才能发起下一个request，而pipeline则废除了这项限制，新的request可以不必等待之前request的response返回就可以立即发送：&lt;/p&gt;
&lt;p&gt;采用管道和不采用管道的请求如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/fengxiu/img/pasted-219.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看出，在使用pipeline机制后，客户端无需等待上一个资源返回后就可以在同一条连接上申请下一个资源。由此可见pipeline技术可以提高每条connection的使用效率，在理想情况下，所有资源的获取仅仅需要一个RTT时长（Round Trip Time），而非pipeline的情况下，所有资源获取需要N个RTT时长（N表示资源个数）。&lt;/p&gt;
&lt;p&gt;在理想情况下，所有资源的获取仅仅需要一个RTT时长，这看上去是非常大的优化和诱惑，但为何主流浏览器上默认下该功能都是关闭状态呢？答案只有一个：&lt;a href=&quot;http://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Head-of-line_blocking&quot;&gt;队头阻塞&lt;/a&gt;。我们上面仅看到了client端可以不必等待上一个response返回即可发送下一个request，但在server端必须根据收到的request的顺序来返回response，这个是因为HTTP是一个无状态的协议，每条request无法知道哪条response是返回给他的。&lt;/p&gt;
&lt;p&gt;管道化的表现可以大大提高页面加载的速度，尤其是在高延迟连接中。 管道化同样也可以减少tcp&amp;#x2F;ip的数据包。通常MSS的大小是在536-1460字节，所以将许多个http请求放在一个tcp&amp;#x2F;ip包 里也是有可能的。减少加载一个网页所需数据包的数量可以在整体上对网络有益处，因为数据包越少，路由器和网络带来的负担就越少。 HTTP&amp;#x2F;1.1需要服务器也支持管道化。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
    <category term="http" scheme="http://fengxiu.club/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Keep-Alive</title>
    <link href="http://fengxiu.club/archives/37f5aa4d.html"/>
    <id>http://fengxiu.club/archives/37f5aa4d.html</id>
    <published>2019-03-10T22:46:00.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;HTTP-Keep-Alive是什么？如何工作？&quot;&gt;&lt;a href=&quot;#HTTP-Keep-Alive是什么？如何工作？&quot; class=&quot;headerlink&quot; title=&quot;HTTP Keep-Alive是什么？如何工作？&quot;&gt;&lt;/a&gt;HTTP Keep-Alive是什么？如何工作？&lt;/h1&gt;&lt;p&gt;在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高http服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。&lt;/p&gt;
&lt;p&gt;但是，&lt;a href=&quot;http://www.nowamagic.net/academy/tag/keep-alive&quot;&gt;keep-alive&lt;/a&gt;并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
    <category term="http" scheme="http://fengxiu.club/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Http值传输编码(Transfer-Encoding)</title>
    <link href="http://fengxiu.club/archives/ce94709.html"/>
    <id>http://fengxiu.club/archives/ce94709.html</id>
    <published>2019-04-18T22:56:16.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文主要讨论HTTP协议中的&lt;strong&gt;Transfer-Encoding&lt;/strong&gt;。Transfer-Encoding，是一个 HTTP 头部字段，字面意思是「传输编码」。实际上，HTTP协议中还有另外一个头部与编码有关：Content-Encoding（内容编码）。Content-Encoding通常用于对实体内容进行压缩编码，目的是优化传输，例如用gzip压缩文本文件，能大幅减小体积。内容编码通常是选择性的，例如&lt;code&gt;jpg/png&lt;/code&gt;这类文件一般不开启，因为图片格式已经是高度压缩过的，再压一遍没什么效果不说还浪费CPU。&lt;/p&gt;
&lt;p&gt;而Transfer-Encoding则是用来改变报文格式(这个可能你现在还不理解，先看后面)，它不但不会减少实体内容传输大小，甚至还会使传输变大，那它的作用是什么呢？本文接下来主要就是讲这个。我们先记住一点，Content-Encoding和Transfer-Encoding二者是相辅相成的，对于一个HTTP报文，很可能同时进行了内容编码和传输编码。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
    <category term="Transfer-Encoding" scheme="http://fengxiu.club/tags/Transfer-Encoding/"/>
    
  </entry>
  
  <entry>
    <title>Http协议中的Content-Encoding</title>
    <link href="http://fengxiu.club/archives/e20a716d.html"/>
    <id>http://fengxiu.club/archives/e20a716d.html</id>
    <published>2019-04-18T22:46:30.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;和&lt;code&gt;Content-Encoding&lt;/code&gt;是HTTP中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。它的工作原理是这样：浏览器发送请求时，通过Accept-Encoding带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过&lt;code&gt;Content-Encoding&lt;/code&gt;响应头指明选定的格式；浏览器拿到响应正文后，依据&lt;code&gt;Content-Encoding&lt;/code&gt;进行解压。当然，服务端也可以返回未压缩的正文，但这种情况不允许返回&lt;code&gt;Content-Encoding&lt;/code&gt;。这个过程就是HTTP的内容编码机制。&lt;/p&gt;
&lt;p&gt;内容编码目的是优化传输内容大小，通俗地讲就是进行压缩。一般经过gzip压缩过的文本响应，只有原始大小的1&amp;#x2F;4。对于文本类响应是否开启了内容压缩，是我们做性能优化时首先要检查的重要项目；而对于&lt;code&gt;JPG/PNG&lt;/code&gt;这类本身已经高度压缩过的二进制文件，不推荐开启内容压缩，效果微乎其微还浪费CPU。不过谷歌开源了一个新的JPG图片压缩算法&lt;a href=&quot;https://github.com/google/guetzli/&quot;&gt;guetzli&lt;/a&gt;,这个算法只有原来的1&amp;#x2F;3大小，有兴趣可以看一下。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
    <category term="Content-Encoding" scheme="http://fengxiu.club/tags/Content-Encoding/"/>
    
    <category term="Accept-Encoding" scheme="http://fengxiu.club/tags/Accept-Encoding/"/>
    
    <category term="请求内容压缩" scheme="http://fengxiu.club/tags/%E8%AF%B7%E6%B1%82%E5%86%85%E5%AE%B9%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>伪共享（false sharing）并发编程无声的性能杀手</title>
    <link href="http://fengxiu.club/archives/50d898f6.html"/>
    <id>http://fengxiu.club/archives/50d898f6.html</id>
    <published>2018-04-10T19:41:00.000Z</published>
    <updated>2022-12-07T03:18:22.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及JVM底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其LMAX架构能够在一个线程里每秒处理6百万订单！在讲到Disruptor为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86&quot;&gt;SMP&lt;/a&gt;系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://fengxiu.club/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://fengxiu.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
