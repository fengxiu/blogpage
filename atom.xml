<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫秀学习日志</title>
  <icon>http://fengxiu.club/icon.png</icon>
  <subtitle>枫秀学习日志</subtitle>
  <link href="http://fengxiu.club/atom.xml" rel="self"/>
  
  <link href="http://fengxiu.club/"/>
  <updated>2022-04-11T14:04:42.000Z</updated>
  <id>http://fengxiu.club/</id>
  
  <author>
    <name>枫秀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql是如何执行查询</title>
    <link href="http://fengxiu.club/archives/63372.html"/>
    <id>http://fengxiu.club/archives/63372.html</id>
    <published>2022-04-11T14:04:42.000Z</published>
    <updated>2022-04-11T14:04:42.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章会按照以下思路来对mysql查询的原理进行讲解，首先讲解mysql是如何在单表上执行查询，在此基础上，讲解多表查询的原理，也就是join时，mysql是如何执行查询的，最后讲解mysql是如何计算查询的成本。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    <category term="读书笔记" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="索引" scheme="http://fengxiu.club/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Innodb索引深入研究</title>
    <link href="http://fengxiu.club/archives/27224.html"/>
    <id>http://fengxiu.club/archives/27224.html</id>
    <published>2022-04-08T11:03:28.000Z</published>
    <updated>2022-04-08T11:03:28.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;之前对索引这块有所了解，也按照一些索引优化实践对表进行过优化，但都是一知半解，不清楚为什么要这么做。本篇文章会对Innodb索引是怎么存储以及怎么使用的进行深入的研究，从而理解索引优化的原理，最后会对索引的使用进行总结。&lt;/p&gt;
&lt;h2 id=&quot;索引存储结构&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="数据库" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    <category term="读书笔记" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="innodb" scheme="http://fengxiu.club/tags/innodb/"/>
    
    <category term="索引" scheme="http://fengxiu.club/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟IP和路由漂移</title>
    <link href="http://fengxiu.club/archives/65008.html"/>
    <id>http://fengxiu.club/archives/65008.html</id>
    <published>2022-04-07T14:55:45.000Z</published>
    <updated>2022-04-07T14:55:45.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在研究网络相关内容，看到虚拟IP相关的内容，之前对这块有一些了解，但都是比较片面的认知，于是花了几天的时间，整理了相关的内容，本篇文章也是对自己整理内容的总结。&lt;/p&gt;
&lt;h2 id=&quot;什么是虚拟ip&quot;&gt;&lt;a href=&quot;#什么是虚拟ip&quot; class=&quot;headerlink&quot; title=&quot;什么是虚拟ip&quot;&gt;&lt;/a&gt;什么是虚拟ip&lt;/h2&gt;&lt;p&gt; 按照维基百科上面的介绍，虚拟IP（Vrtual IP Address，vip）是一种不与特定计算机或者特定计算机网卡相对应的IP地址。所有发往这个IP地址的数据包最后都会经过真实的网卡到达目的主机的目的进程。主要是用来网络地址转换，网络容错和可移动性。&lt;/p&gt;
&lt;p&gt;这种定义确实准确的定义了什么是虚拟IP，不过看完之后还是摸不着头脑。下面通过一个例子来介绍VIP。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="虚拟ip" scheme="http://fengxiu.club/tags/%E8%99%9A%E6%8B%9Fip/"/>
    
    <category term="高可用" scheme="http://fengxiu.club/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Innodb行格式</title>
    <link href="http://fengxiu.club/archives/43453.html"/>
    <id>http://fengxiu.club/archives/43453.html</id>
    <published>2022-04-01T14:25:20.000Z</published>
    <updated>2022-04-01T14:25:39.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;InnoDB是mysql数据库中最常用的存储引擎，对其底层进行研究有助于理解常见的一些数据库优化思路。本篇文章介绍一条记录是如何存储在磁盘上。&lt;/p&gt;
&lt;p&gt;我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也被称为行格式或者记录格式。InnoDB存储引擎到现在为止设计了4种不同类型的行格式，&lt;br&gt;分别是COMPACT、REDUNDANT、DYNAMI、COMPRESSED。其中REDUNDANT是最早使用的数据格式，现在基本上不怎么使用。目前使用较多的是其它三种格式，这三种格式基本相似，只在处理变长字段上有不同。下文将首先介绍COMPACT格式，然后在以此对比来说明另外俩种格式。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://fengxiu.club/categories/mysql/"/>
    
    <category term="读书笔记" scheme="http://fengxiu.club/categories/mysql/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="mysql" scheme="http://fengxiu.club/tags/mysql/"/>
    
    <category term="Innodb" scheme="http://fengxiu.club/tags/Innodb/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务之本地事务表和事务消息</title>
    <link href="http://fengxiu.club/archives/61416.html"/>
    <id>http://fengxiu.club/archives/61416.html</id>
    <published>2022-03-31T16:12:28.000Z</published>
    <updated>2022-03-31T16:12:28.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在一些业务场景中，对于数据的强一致性并不是严格要求。比如用户购买商品时增加用户的积分，对于用户来说，重要的是下单成功，至于增加积分相对不是非常重要，在一段时间内保证用户的积分增加成功即可。对于这类场景，可以使用最终一致性的方案，带来的好处是可以增加应用的可用性以及qps。&lt;/p&gt;
&lt;p&gt;本文介绍实现最终一致性的俩种方案，本地事务表和事务消息，俩种方案的核心思想都是将一个大事务拆分长一系列的小事务，通过重试机制保证一致性。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://fengxiu.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://fengxiu.club/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="事务消息" scheme="http://fengxiu.club/tags/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    
    <category term="本地事务表" scheme="http://fengxiu.club/tags/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>本地事务表 (An Acid Alternative)</title>
    <link href="http://fengxiu.club/archives/6735.html"/>
    <id>http://fengxiu.club/archives/6735.html</id>
    <published>2022-03-28T19:19:51.000Z</published>
    <updated>2022-03-28T19:19:51.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;https://queue.acm.org/detail.cfm?id=1394128&quot;&gt;Base: An Acid Alternative&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在分区数据库中，用一致性换取可用性可以显著提高可伸缩性。&lt;/p&gt;
&lt;p&gt;Web应用程序在过去十年中越来越流行。无论您是为终端用户还是为应用程序开发人员（服务）构建应用程序，您最希望的是您的应用程序将获得广泛采用，并且随着广泛采用，将带来事务性增长。如果应用程序依赖持久性，那么数据存储可能会成为瓶颈。&lt;/p&gt;
&lt;p&gt;有两种策略可以扩展任何应用程序。第一个，也是迄今为止最简单的，是垂直扩展：将应用程序移动到更大的计算机上。垂直缩放对数据的效果相当好，但有几个限制。最明显的限制是超出了最大系统的容量。垂直扩展也很昂贵，因为增加事务处理能力通常需要购买下一个更大的系统。垂直扩展通常会造成供应商锁定，进一步增加成本。&lt;/p&gt;
&lt;p&gt;水平缩放提供了更大的灵活性，但也相当复杂。水平数据缩放可以沿两个方向执行。功能扩展涉及按功能对数据进行分组，并将功能组分布在数据库中。将功能区域内的数据跨多个数据库拆分，或进行切分，即第二种策略。下图解释了水平数据缩放策略。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://fengxiu.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="翻译" scheme="http://fengxiu.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="分布式" scheme="http://fengxiu.club/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="翻译" scheme="http://fengxiu.club/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>seata简单总结</title>
    <link href="http://fengxiu.club/archives/59493.html"/>
    <id>http://fengxiu.club/archives/59493.html</id>
    <published>2022-03-28T14:34:49.000Z</published>
    <updated>2022-03-28T14:34:49.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;收集信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://seata.io/zh-cn/docs/overview/what-is-seata.html&quot;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a</summary>
        
      
    
    
    
    <category term="分布式" scheme="http://fengxiu.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式事务" scheme="http://fengxiu.club/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="seata" scheme="http://fengxiu.club/tags/seata/"/>
    
  </entry>
  
  <entry>
    <title>快速生成测试数据</title>
    <link href="http://fengxiu.club/archives/21834.html"/>
    <id>http://fengxiu.club/archives/21834.html</id>
    <published>2022-03-22T17:11:44.000Z</published>
    <updated>2022-03-22T17:11:44.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;日常在写单元测试过程中，如何构造合适的测试数据是比较麻烦并且乏味的。本篇将介绍俩个工具用于生成测试数据，首先介绍&lt;a href=&quot;https://www.datafaker.net/documentation/getting-started/&quot;&gt;Datafaker&lt;/a&gt;，此工具用于生成各种常见的测试数据。接着介绍&lt;a href=&quot;https://github.com/j-easy/easy-random/wiki&quot;&gt;easy-random&lt;/a&gt;,用于生成测试对象。最后介绍如何结合这俩个工具生成比较真实的测试对象。&lt;/p&gt;</summary>
    
    
    
    <category term="test" scheme="http://fengxiu.club/categories/test/"/>
    
    
    <category term="test" scheme="http://fengxiu.club/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>spring之aop源码解析</title>
    <link href="http://fengxiu.club/archives/1930.html"/>
    <id>http://fengxiu.club/archives/1930.html</id>
    <published>2022-03-14T17:58:06.000Z</published>
    <updated>2022-03-14T17:58:06.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章主要用来记录研究aop源码的过程。&lt;/p&gt;
&lt;h2 id=&quot;aop-基本概念&quot;&gt;&lt;a href=&quot;#aop-基本概念&quot; class=&quot;headerlink&quot; title=&quot;aop 基本概念&quot;&gt;&lt;/a&gt;aop 基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;方面（Aspect）：跨越多个类的模块化关注点。事务管理是企业Java应用程序中横切关注点的一个很好的例子。在SpringAOP中，方面是通过使用常规类（基于xml的方法）或使用@Aspect注解（@Aspectj样式）注解的常规类来实现的。&lt;/li&gt;
&lt;li&gt;连接点（Join point）：程序执行过程中的一点，如方法的执行或异常的处理。在SpringAOP中，连接点总是表示一个方法执行。&lt;/li&gt;
&lt;li&gt;通知（Advice）：一个方面在特定连接点采取的行动。不同类型的通知包括“环绕”、“前“和”后”通知。（稍后将讨论通知类型。）许多AOP框架（包括Spring）将通知建模为拦截器，并在连接点周围维护拦截器链。&lt;/li&gt;
&lt;li&gt;切点（Pointcut）：与连接点匹配的谓词。通知与切入点表达式关联，并在与切入点匹配的任何连接点上运行（例如，使用特定名称执行方法）。pointcut表达式匹配的连接点概念是AOP的核心，Spring默认使用AspectJ pointcut表达式语言。&lt;/li&gt;
&lt;li&gt;引入（Introduction）：代表类型声明其他方法或字段。SpringAOP允许你向任何advised对象引入新的接口（和相应的实现）。例如，你可以使用一个Introduction使bean实现一个IsModified接口，以简化缓存。（introduction在AspectJ社区中称为类型间声明。）&lt;/li&gt;
&lt;li&gt;目标对象（Target object）：由一个或多个方面advised的对象。也称为“advised 对象”。因为SpringAOP是通过使用运行时代理实现的，所以这个对象始终是一个代理对象。&lt;/li&gt;
&lt;li&gt;AOP代理：由AOP框架创建的用于实现aspect contracts（通知方法执行等）的对象。在Spring框架中，AOP代理是JDK动态代理或CGLIB代理。&lt;/li&gt;
&lt;li&gt;编织（Weaving）：将aspects与其他应用程序类型或对象链接，以创建advised的对象。这可以在编译时（例如，使用AspectJ编译器）、加载时或运行时完成。Spring AOP和其他纯Java AOP框架一样，在运行时进行编织。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring AOP包含以下几种通知类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before advice:在连接点之前运行但不能阻止执行到连接点的通知（除非它抛出异常）。&lt;/li&gt;
&lt;li&gt;After returning advice:在连接点正常完成后要运行的通知（例如，如果方法返回并且不引发异常）。&lt;/li&gt;
&lt;li&gt;After throwing advice: 如果方法通过引发异常而退出，则要执行的通知。&lt;/li&gt;
&lt;li&gt;After (finally) advice:无论连接点退出的方式如何（正常或异常返回），都要执行的通知。&lt;/li&gt;
&lt;li&gt;Around advice:环绕连接点（如方法调用）的通知。这是最有力的通知。around通知可以在方法调用前后执行自定义行为。它还负责通过返回自己的返回值或引发异常来选择是继续到连接点还是快捷地执行通知的方法。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="spring" scheme="http://fengxiu.club/categories/spring/"/>
    
    <category term="aop" scheme="http://fengxiu.club/categories/spring/aop/"/>
    
    <category term="源码解析" scheme="http://fengxiu.club/categories/spring/aop/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="spring" scheme="http://fengxiu.club/tags/spring/"/>
    
    <category term="aop" scheme="http://fengxiu.club/tags/aop/"/>
    
    <category term="源码解析" scheme="http://fengxiu.club/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>spring之@import注解使用与源码解析</title>
    <link href="http://fengxiu.club/archives/undefined.html"/>
    <id>http://fengxiu.club/archives/undefined.html</id>
    <published>2022-03-10T14:39:08.000Z</published>
    <updated>2022-04-13T07:28:48.840Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章记录对@Import注解学习的整个过程。首先文章会介绍@Import注解的使用，接着分析下spring是如何处理@Import注解，最后通过@EnableAsync来举例说明该类型注解实现的原理。&lt;/p&gt;
&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;大体上有三种用法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入其它Configuration&lt;/li&gt;
&lt;li&gt;初始化其它的bean&lt;/li&gt;
&lt;li&gt;个性化加载bean&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面依次介绍这三种的用法，首先定义几个类，方便后面的讲解&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceInterface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceA&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceInterface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;ServiceA&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceInterface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;ServiceB&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;引入configuration&quot;&gt;&lt;a href=&quot;#引入configuration&quot; class=&quot;headerlink&quot; title=&quot;引入configuration&quot;&gt;&lt;/a&gt;引入configuration&lt;/h3&gt;&lt;p&gt;创建了俩个Config类，其中ConfigA通过@Import引入ConfigB，&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Import(ConfigB.class)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConfigA&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ServiceInterface &lt;span class=&quot;title function_&quot;&gt;getServiceA&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceA&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConfigB&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ServiceInterface &lt;span class=&quot;title function_&quot;&gt;getServiceB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceB&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;同时这里也使用了ConditionalOnMissingBean注解，主要用于判断哪个bean先生成。&lt;/p&gt;
&lt;p&gt;通过ConfigA创建AnnotationConfigApplicationContext，获取ServiceInterface，看是哪种实现：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;(ConfigA.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ServiceInterface&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; ctx.getBean(ServiceInterface.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bean.test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出为：ServiceB.证明@Import的优先于本身的的类定义加载。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="http://fengxiu.club/categories/spring/"/>
    
    <category term="java" scheme="http://fengxiu.club/categories/spring/java/"/>
    
    
    <category term="spring" scheme="http://fengxiu.club/tags/spring/"/>
    
    <category term="java" scheme="http://fengxiu.club/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring类型转换整理</title>
    <link href="http://fengxiu.club/archives/22104.html"/>
    <id>http://fengxiu.club/archives/22104.html</id>
    <published>2021-11-11T06:46:00.000Z</published>
    <updated>2022-04-13T07:28:48.840Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring类型转换整理&quot;&gt;&lt;a href=&quot;#Spring类型转换整理&quot; class=&quot;headerlink&quot; title=&quot;Spring类型转换整理&quot;&gt;&lt;/a&gt;Spring类型转换整理&lt;/h1&gt;&lt;!-- 

https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API

https://blog.csdn.net/f641385712/article/details/90702928

https://juejin.im/post/6844903940484513806

1. BeanWrapperImpl 大致原理 https://juejin.im/post/6844904047070167054#heading-4
2. convert 包的基本使用
3. fromat的基本使用
 --&gt;
&lt;p&gt; 平常在使用Spring过程中，经常会用到类型转换，但一直没时间对这一块进行系统的整理。因此接下来会用几篇文章对这一块进行系统的整理。&lt;/p&gt;
&lt;p&gt;大概的想法是下面俩篇：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spring类型转换整理&lt;/li&gt;
&lt;li&gt;BeanWrapper使用以及原理&lt;/li&gt;
&lt;li&gt;DataBinder使用以及原理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这篇文章用于记录自己在学习Spring类型转换相关的内容，主要有以下三块。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PropertyEditor：用于String到Object的类型转换&lt;/li&gt;
&lt;li&gt;Conver      ：用于Object到Object之间的转换&lt;/li&gt;
&lt;li&gt;Format      ：主要用于格式化，将对象转换成指定格式的字符串，比如Date和string之间的转换</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="spring" scheme="http://fengxiu.club/categories/java/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>外观模式</title>
    <link href="http://fengxiu.club/archives/f7de8aa8.html"/>
    <id>http://fengxiu.club/archives/f7de8aa8.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.848Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h1&gt;&lt;p&gt;外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。&lt;/p&gt;
&lt;p&gt;最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://fengxiu.club/archives/f5c535ea.html"/>
    <id>http://fengxiu.club/archives/f5c535ea.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.848Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;p&gt;适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。&lt;/p&gt;
&lt;p&gt;在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fengxiu/img/master/problem-zh-2x.png&quot; alt=&quot;problem-zh-2x&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>inux 查看文件命令</title>
    <link href="http://fengxiu.club/archives/b4c41cf9.html"/>
    <id>http://fengxiu.club/archives/b4c41cf9.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.844Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;linux-查看文件命令&quot;&gt;&lt;a href=&quot;#linux-查看文件命令&quot; class=&quot;headerlink&quot; title=&quot;linux 查看文件命令&quot;&gt;&lt;/a&gt;linux 查看文件命令&lt;/h1&gt;&lt;p&gt;当我们在进行调试的时候，经常需要查看各种日志文件，这时候熟悉linux下一些常用的查看文件命令是非常重要的，本篇文章专门整理了这些常用的命令，主要有下面几个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tail&lt;/li&gt;
&lt;li&gt;cat&lt;/li&gt;
&lt;li&gt;more&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;tail命令&quot;&gt;&lt;a href=&quot;#tail命令&quot; class=&quot;headerlink&quot; title=&quot;tail命令&quot;&gt;&lt;/a&gt;tail命令&lt;/h2&gt;&lt;p&gt;ltail命令用途是依照要求将指定的文件的最后部分输出到标准设备，通常是终端，通俗讲来，就是把某个文件的最后几行显示到终端上，假设该文件有更新，tail会自己主动刷新，确保你看到最新的文件内容。&lt;/p&gt;
&lt;h3 id=&quot;tail命令语法&quot;&gt;&lt;a href=&quot;#tail命令语法&quot; class=&quot;headerlink&quot; title=&quot;tail命令语法&quot;&gt;&lt;/a&gt;tail命令语法&lt;/h3&gt;&lt;p&gt;tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ]  [-r]  [ File ]&lt;/p&gt;
&lt;p&gt;参数解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-f 该参数用于监视File文件动态增长。&lt;/li&gt;
&lt;li&gt;-c Number 从 Number 字节位置读取指定文件&lt;/li&gt;
&lt;li&gt;-n Number 从 Number 行位置读取指定文件。&lt;/li&gt;
&lt;li&gt;-m Number 从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题。&lt;/li&gt;
&lt;li&gt;-b Number 从 Number 表示的512字节块位置读取指定文件。&lt;/li&gt;
&lt;li&gt;-k Number 从 Number 表示的1KB块位置读取指定文件。&lt;/li&gt;
&lt;li&gt;-r 这个会似的按照现实内容相反的顺序现实，具体见下面例子 &lt;/li&gt;
&lt;li&gt;File 指定操作的目标文件名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述命令中，都涉及到number，假设不指定，默认显示10行。Number前面可使用正负号，表示该偏移从顶部还是从尾部开始计算。这个具体看下面例子。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://fengxiu.club/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hiberate Validator使用教程之自定义约束</title>
    <link href="http://fengxiu.club/archives/76d29d45.html"/>
    <id>http://fengxiu.club/archives/76d29d45.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.844Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Hiberate-Validator使用教程之自定义约束&quot;&gt;&lt;a href=&quot;#Hiberate-Validator使用教程之自定义约束&quot; class=&quot;headerlink&quot; title=&quot;Hiberate Validator使用教程之自定义约束&quot;&gt;&lt;/a&gt;Hiberate Validator使用教程之自定义约束&lt;/h1&gt;&lt;!-- 
    1. 创建自定义约束
    2. 自定义错误信息配置
 --&gt;
&lt;p&gt; 前面一篇文章已经讲解了Hibernate Validator的基本使用。虽然校验库本身已经提供了许多的约束，但是不一定能够满足不同功能的需要，这时就需要自定义一些约束，本篇文章主要就是来学习如何自定义约束。&lt;/p&gt;
&lt;h2 id=&quot;简单例子&quot;&gt;&lt;a href=&quot;#简单例子&quot; class=&quot;headerlink&quot; title=&quot;简单例子&quot;&gt;&lt;/a&gt;简单例子&lt;/h2&gt;&lt;p&gt;创建一个简单的自定义约束分为以下三步&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个约束注解&lt;/li&gt;
&lt;li&gt;实现一个约束注解对应的Validator&lt;/li&gt;
&lt;li&gt;定义一个默认的错误信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的这个例子，是用来判断某个String字段是否是全部大小字段或者小写字段。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="教程" scheme="http://fengxiu.club/categories/java/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>maven冲突解决流程</title>
    <link href="http://fengxiu.club/archives/afb2f833.html"/>
    <id>http://fengxiu.club/archives/afb2f833.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.844Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;maven冲突解决流程&quot;&gt;&lt;a href=&quot;#maven冲突解决流程&quot; class=&quot;headerlink&quot; title=&quot;maven冲突解决流程&quot;&gt;&lt;/a&gt;maven冲突解决流程&lt;/h1&gt;&lt;!-- 
    mvn dependency 简介
    常见命令介绍
    错误处理
 --&gt;

&lt;p&gt; 当项目比较大且开发维护的时间比较长时，项目的Maven依赖管理也会变得越来越复杂，手动的去排除冲突或者错误已经变得很困难，同时由于开发人员的不规范行为，更一步加深maven的依赖冲突比较多。我也是最近在接手一个已经做了八年项目时才有很大的感悟，之前也没碰过这么久的项目，在自己对maven依赖冲突解决的过程中形成了以下的一些思考或者说技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="构建工具" scheme="http://fengxiu.club/categories/java/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>maven依赖机制简介</title>
    <link href="http://fengxiu.club/archives/d2073860.html"/>
    <id>http://fengxiu.club/archives/d2073860.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.844Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;maven依赖机制简介&quot;&gt;&lt;a href=&quot;#maven依赖机制简介&quot; class=&quot;headerlink&quot; title=&quot;maven依赖机制简介&quot;&gt;&lt;/a&gt;maven依赖机制简介&lt;/h1&gt;&lt;p&gt;本文主要是对maven官方文档&lt;a href=&quot;https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#introduction-to-the-dependency-mechanism&quot;&gt;Introduction to the Dependency Mechanism&lt;/a&gt;翻译与整理。其中加上了自己的一些理解。&lt;/p&gt;
&lt;p&gt;依赖关系管理是Maven的一个核心特性。管理单个项目的依赖关系很容易。管理由数百个模块组成的多模块项目和应用程序的依赖关系是可能的。Maven在定义、创建和维护具有良好定义的ClassPath路径和Library版本的可复制构建方面有很大帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="构建工具" scheme="http://fengxiu.club/categories/java/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring注解@Autoired和@Resource区别对比</title>
    <link href="http://fengxiu.club/archives/d1a2b8ab.html"/>
    <id>http://fengxiu.club/archives/d1a2b8ab.html</id>
    <published>2020-11-11T06:46:00.000Z</published>
    <updated>2022-04-13T07:28:48.836Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring注解-Autoired和-Resource区别对比&quot;&gt;&lt;a href=&quot;#Spring注解-Autoired和-Resource区别对比&quot; class=&quot;headerlink&quot; title=&quot;Spring注解@Autoired和@Resource区别对比&quot;&gt;&lt;/a&gt;Spring注解@Autoired和@Resource区别对比&lt;/h1&gt;&lt;!-- 
    1. 简单介绍
    2. @Autowired具体使用
    3. @Resouece具体使用
    4. 俩者对比
    5. 扩展介绍，@Primary @Qualifiers
 --&gt;

&lt;p&gt;最近在做项目的时候，由于自己的不细心，导致了一个小错误，在进行bean定义的时候，出现了俩个Bean名字相同但类型不通的Bean，而在进行依赖注入的时候，我选用了@Resource作为注入属性的注解，倒置了项目启动不成功，经过查阅资料，发现是自己对于@Resource注解的使用理解不到位导致的，因此这里有必要对依赖注入使用的注解进行整理分析。&lt;/p&gt;
&lt;p&gt;本文主要对@Resource和@Autowired俩个注解的用法，以及俩者的对比进行整理。并子啊最后对和它们搭配使用的@Qualifiers和@Primary进行整理。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="spring" scheme="http://fengxiu.club/categories/java/spring/"/>
    
    <category term="spring" scheme="http://fengxiu.club/categories/java/spring/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>URL详解</title>
    <link href="http://fengxiu.club/archives/236c7534.html"/>
    <id>http://fengxiu.club/archives/236c7534.html</id>
    <published>2020-09-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.840Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;URL详解&quot;&gt;&lt;a href=&quot;#URL详解&quot; class=&quot;headerlink&quot; title=&quot;URL详解&quot;&gt;&lt;/a&gt;URL详解&lt;/h1&gt;&lt;!-- 
    1. 简单介绍
    2. 简单使用
    3. URLConnection简单介绍与使用
    4. URLStreamHandler 简单介绍
    5. 
 --&gt;

&lt;p&gt; 平时看源码中，发现很多开源库都会使用URL这个类，因此有必要对这个类的使用以及原理做一个总结。&lt;/p&gt;
&lt;p&gt;这里先简单介绍一个概念，URL（Uniform Resource Locator）中文名为统一资源定位符，有时也被俗称为网页地址。表示为互联网上的资源，如网页或者FTP地址。&lt;/p&gt;
&lt;p&gt;URL可以分为如下几个部分&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protocol://host:port/path?query#fragment&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="基础" scheme="http://fengxiu.club/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Hibernate Validator 学习与使用</title>
    <link href="http://fengxiu.club/archives/fc06a9d1.html"/>
    <id>http://fengxiu.club/archives/fc06a9d1.html</id>
    <published>2020-09-28T10:09:53.000Z</published>
    <updated>2022-04-13T07:28:48.844Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Hibernate-Validator-学习与使用&quot;&gt;&lt;a href=&quot;#Hibernate-Validator-学习与使用&quot; class=&quot;headerlink&quot; title=&quot;Hibernate Validator 学习与使用&quot;&gt;&lt;/a&gt;Hibernate Validator 学习与使用&lt;/h1&gt;&lt;!-- 
    1.  配置
    2.  简单的demo
    3.  如何声明和校验约束 : 约束集成，级联约束
    4.  自定义约束
    5.  配置约束错误语句
    6.  配置ValueExectuao
    7.  配置Validator
    8.  
 --&gt;
&lt;p&gt;在项目，校验数据是必不可少的一步。因此如果能写出一个好的校验代码，必定能提高项目的鲁棒性。目前我做的项目大部分使用的是SpringBoot，基本上都是在控制器那一层通过注解@Valid等来校验参数，虽然经常使用，但是没有好好的进行整理。所以接下来会写几篇文章，对这一块进行整理。&lt;/p&gt;
&lt;p&gt;大概会整理如下几个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hibernate Validator的用法，&lt;/li&gt;
&lt;li&gt;如何在Spring中使用Hibernate Validator&lt;/li&gt;
&lt;li&gt;介绍如何在Spring MVC中使用。&lt;/li&gt;
&lt;li&gt;分析Spring MVC使用Validator的原理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本篇文章主要是对Hibernate Validator用法进行简单的介绍&lt;/p&gt;
&lt;h2 id=&quot;Hibernate-Validator简介&quot;&gt;&lt;a href=&quot;#Hibernate-Validator简介&quot; class=&quot;headerlink&quot; title=&quot;Hibernate Validator简介&quot;&gt;&lt;/a&gt;Hibernate Validator简介&lt;/h2&gt;&lt;p&gt;验证数据是贯穿所有应用程序层（从应用层到持久层）的常见任务。通常在每一层都实现相同的验证逻辑，这是非常耗时和容易出错的。为了避免这些验证的重复，开发人员经常将验证逻辑直接绑定到域模型中，用验证代码（实际上是关于类本身的元数据）将域类弄乱。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fengxiu/img/master/application-layers.png&quot; alt=&quot;application-layers&quot;&gt;&lt;/p&gt;
&lt;p&gt;Jakarta Bean Validation 2.0——为Entity和方法的验证定义了一个元数据模型和API。默认的元数据源是Annotation，同时也能够通过使用XML覆盖和扩展元数据。API没有绑定到特定的应用层或者programming model.。它与web层或持久层都没有强绑定，可用于服务器端应用程序编程和客户端上应用程序。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fengxiu/img/master/application-layers2.png&quot; alt=&quot;application-layers2&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hibernate Validator和Jakarta Bean Validation的区别：Jakarta Bean Validation是一种规范，Hibernate Validator是对个规范的一种实现。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="教程" scheme="http://fengxiu.club/categories/java/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
