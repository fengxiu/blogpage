<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫秀学习日志</title>
  <icon>http://fengxiu.club/icon.png</icon>
  <subtitle>枫秀学习日志</subtitle>
  <link href="http://fengxiu.club/atom.xml" rel="self"/>
  
  <link href="http://fengxiu.club/"/>
  <updated>2022-03-28T14:34:49.000Z</updated>
  <id>http://fengxiu.club/</id>
  
  <author>
    <name>枫秀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>seata简单总结</title>
    <link href="http://fengxiu.club/archives/59493.html"/>
    <id>http://fengxiu.club/archives/59493.html</id>
    <published>2022-03-28T14:34:49.000Z</published>
    <updated>2022-03-28T14:34:49.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;收集信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://seata.io/zh-cn/docs/overview/what-is-seata.html&quot;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a</summary>
        
      
    
    
    
    <category term="分布式" scheme="http://fengxiu.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式事务" scheme="http://fengxiu.club/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="seata" scheme="http://fengxiu.club/tags/seata/"/>
    
  </entry>
  
  <entry>
    <title>快速生成测试数据</title>
    <link href="http://fengxiu.club/archives/21834.html"/>
    <id>http://fengxiu.club/archives/21834.html</id>
    <published>2022-03-22T17:11:44.000Z</published>
    <updated>2022-03-22T17:11:44.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;日常在写单元测试过程中，如何构造合适的测试数据是比较麻烦并且乏味的。本篇将介绍俩个工具用于生成测试数据，首先介绍&lt;a href=&quot;https://www.datafaker.net/documentation/getting-started/&quot;&gt;Datafaker&lt;/a&gt;，此工具用于生成各种常见的测试数据。接着介绍&lt;a href=&quot;https://github.com/j-easy/easy-random/wiki&quot;&gt;easy-random&lt;/a&gt;,用于生成测试对象。最后介绍如何结合这俩个工具生成比较真实的测试对象。&lt;/p&gt;</summary>
    
    
    
    <category term="test" scheme="http://fengxiu.club/categories/test/"/>
    
    
    <category term="test" scheme="http://fengxiu.club/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>spring之aop源码解析</title>
    <link href="http://fengxiu.club/archives/1930.html"/>
    <id>http://fengxiu.club/archives/1930.html</id>
    <published>2022-03-14T17:58:06.000Z</published>
    <updated>2022-03-14T17:58:06.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章主要用来记录研究aop源码的过程。&lt;/p&gt;
&lt;h2 id=&quot;aop-基本概念&quot;&gt;&lt;a href=&quot;#aop-基本概念&quot; class=&quot;headerlink&quot; title=&quot;aop 基本概念&quot;&gt;&lt;/a&gt;aop 基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;方面（Aspect）：跨越多个类的模块化关注点。事务管理是企业Java应用程序中横切关注点的一个很好的例子。在SpringAOP中，方面是通过使用常规类（基于xml的方法）或使用@Aspect注解（@Aspectj样式）注解的常规类来实现的。&lt;/li&gt;
&lt;li&gt;连接点（Join point）：程序执行过程中的一点，如方法的执行或异常的处理。在SpringAOP中，连接点总是表示一个方法执行。&lt;/li&gt;
&lt;li&gt;通知（Advice）：一个方面在特定连接点采取的行动。不同类型的通知包括“环绕”、“前“和”后”通知。（稍后将讨论通知类型。）许多AOP框架（包括Spring）将通知建模为拦截器，并在连接点周围维护拦截器链。&lt;/li&gt;
&lt;li&gt;切点（Pointcut）：与连接点匹配的谓词。通知与切入点表达式关联，并在与切入点匹配的任何连接点上运行（例如，使用特定名称执行方法）。pointcut表达式匹配的连接点概念是AOP的核心，Spring默认使用AspectJ pointcut表达式语言。&lt;/li&gt;
&lt;li&gt;引入（Introduction）：代表类型声明其他方法或字段。SpringAOP允许你向任何advised对象引入新的接口（和相应的实现）。例如，你可以使用一个Introduction使bean实现一个IsModified接口，以简化缓存。（introduction在AspectJ社区中称为类型间声明。）&lt;/li&gt;
&lt;li&gt;目标对象（Target object）：由一个或多个方面advised的对象。也称为“advised 对象”。因为SpringAOP是通过使用运行时代理实现的，所以这个对象始终是一个代理对象。&lt;/li&gt;
&lt;li&gt;AOP代理：由AOP框架创建的用于实现aspect contracts（通知方法执行等）的对象。在Spring框架中，AOP代理是JDK动态代理或CGLIB代理。&lt;/li&gt;
&lt;li&gt;编织（Weaving）：将aspects与其他应用程序类型或对象链接，以创建advised的对象。这可以在编译时（例如，使用AspectJ编译器）、加载时或运行时完成。Spring AOP和其他纯Java AOP框架一样，在运行时进行编织。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring AOP包含以下几种通知类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before advice:在连接点之前运行但不能阻止执行到连接点的通知（除非它抛出异常）。&lt;/li&gt;
&lt;li&gt;After returning advice:在连接点正常完成后要运行的通知（例如，如果方法返回并且不引发异常）。&lt;/li&gt;
&lt;li&gt;After throwing advice: 如果方法通过引发异常而退出，则要执行的通知。&lt;/li&gt;
&lt;li&gt;After (finally) advice:无论连接点退出的方式如何（正常或异常返回），都要执行的通知。&lt;/li&gt;
&lt;li&gt;Around advice:环绕连接点（如方法调用）的通知。这是最有力的通知。around通知可以在方法调用前后执行自定义行为。它还负责通过返回自己的返回值或引发异常来选择是继续到连接点还是快捷地执行通知的方法。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="spring" scheme="http://fengxiu.club/categories/spring/"/>
    
    <category term="aop" scheme="http://fengxiu.club/categories/spring/aop/"/>
    
    <category term="源码解析" scheme="http://fengxiu.club/categories/spring/aop/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="spring" scheme="http://fengxiu.club/tags/spring/"/>
    
    <category term="aop" scheme="http://fengxiu.club/tags/aop/"/>
    
    <category term="源码解析" scheme="http://fengxiu.club/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>spring之@import注解使用与源码解析</title>
    <link href="http://fengxiu.club/archives/undefined.html"/>
    <id>http://fengxiu.club/archives/undefined.html</id>
    <published>2022-03-10T14:39:08.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章记录对@Import注解学习的整个过程。首先文章会介绍@Import注解的使用，接着分析下spring是如何处理@Import注解，最后通过@EnableAsync来举例说明该类型注解实现的原理。&lt;/p&gt;
&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;大体上有三种用法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入其它Configuration&lt;/li&gt;
&lt;li&gt;初始化其它的bean&lt;/li&gt;
&lt;li&gt;个性化加载bean&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面依次介绍这三种的用法，首先定义几个类，方便后面的讲解&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceInterface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceA&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceInterface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;ServiceA&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceInterface&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;ServiceB&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;引入configuration&quot;&gt;&lt;a href=&quot;#引入configuration&quot; class=&quot;headerlink&quot; title=&quot;引入configuration&quot;&gt;&lt;/a&gt;引入configuration&lt;/h3&gt;&lt;p&gt;创建了俩个Config类，其中ConfigA通过@Import引入ConfigB，&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Import(ConfigB.class)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConfigA&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ServiceInterface &lt;span class=&quot;title function_&quot;&gt;getServiceA&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceA&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConfigB&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ServiceInterface &lt;span class=&quot;title function_&quot;&gt;getServiceB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceB&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;同时这里也使用了ConditionalOnMissingBean注解，主要用于判断哪个bean先生成。&lt;/p&gt;
&lt;p&gt;通过ConfigA创建AnnotationConfigApplicationContext，获取ServiceInterface，看是哪种实现：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;(ConfigA.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ServiceInterface&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; ctx.getBean(ServiceInterface.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bean.test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出为：ServiceB.证明@Import的优先于本身的的类定义加载。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="http://fengxiu.club/categories/spring/"/>
    
    <category term="java" scheme="http://fengxiu.club/categories/spring/java/"/>
    
    
    <category term="spring" scheme="http://fengxiu.club/tags/spring/"/>
    
    <category term="java" scheme="http://fengxiu.club/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring类型转换整理</title>
    <link href="http://fengxiu.club/archives/22104.html"/>
    <id>http://fengxiu.club/archives/22104.html</id>
    <published>2021-11-11T06:46:00.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring类型转换整理&quot;&gt;&lt;a href=&quot;#Spring类型转换整理&quot; class=&quot;headerlink&quot; title=&quot;Spring类型转换整理&quot;&gt;&lt;/a&gt;Spring类型转换整理&lt;/h1&gt;&lt;!-- 

https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API

https://blog.csdn.net/f641385712/article/details/90702928

https://juejin.im/post/6844903940484513806

1. BeanWrapperImpl 大致原理 https://juejin.im/post/6844904047070167054#heading-4
2. convert 包的基本使用
3. fromat的基本使用
 --&gt;
&lt;p&gt; 平常在使用Spring过程中，经常会用到类型转换，但一直没时间对这一块进行系统的整理。因此接下来会用几篇文章对这一块进行系统的整理。&lt;/p&gt;
&lt;p&gt;大概的想法是下面俩篇：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spring类型转换整理&lt;/li&gt;
&lt;li&gt;BeanWrapper使用以及原理&lt;/li&gt;
&lt;li&gt;DataBinder使用以及原理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这篇文章用于记录自己在学习Spring类型转换相关的内容，主要有以下三块。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PropertyEditor：用于String到Object的类型转换&lt;/li&gt;
&lt;li&gt;Conver      ：用于Object到Object之间的转换&lt;/li&gt;
&lt;li&gt;Format      ：主要用于格式化，将对象转换成指定格式的字符串，比如Date和string之间的转换</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="spring" scheme="http://fengxiu.club/categories/java/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>外观模式</title>
    <link href="http://fengxiu.club/archives/f7de8aa8.html"/>
    <id>http://fengxiu.club/archives/f7de8aa8.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.534Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h1&gt;&lt;p&gt;外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。&lt;/p&gt;
&lt;p&gt;最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://fengxiu.club/archives/f5c535ea.html"/>
    <id>http://fengxiu.club/archives/f5c535ea.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.534Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;p&gt;适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。&lt;/p&gt;
&lt;p&gt;在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fengxiu/img/master/problem-zh-2x.png&quot; alt=&quot;problem-zh-2x&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>inux 查看文件命令</title>
    <link href="http://fengxiu.club/archives/b4c41cf9.html"/>
    <id>http://fengxiu.club/archives/b4c41cf9.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;linux-查看文件命令&quot;&gt;&lt;a href=&quot;#linux-查看文件命令&quot; class=&quot;headerlink&quot; title=&quot;linux 查看文件命令&quot;&gt;&lt;/a&gt;linux 查看文件命令&lt;/h1&gt;&lt;p&gt;当我们在进行调试的时候，经常需要查看各种日志文件，这时候熟悉linux下一些常用的查看文件命令是非常重要的，本篇文章专门整理了这些常用的命令，主要有下面几个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tail&lt;/li&gt;
&lt;li&gt;cat&lt;/li&gt;
&lt;li&gt;more&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;tail命令&quot;&gt;&lt;a href=&quot;#tail命令&quot; class=&quot;headerlink&quot; title=&quot;tail命令&quot;&gt;&lt;/a&gt;tail命令&lt;/h2&gt;&lt;p&gt;ltail命令用途是依照要求将指定的文件的最后部分输出到标准设备，通常是终端，通俗讲来，就是把某个文件的最后几行显示到终端上，假设该文件有更新，tail会自己主动刷新，确保你看到最新的文件内容。&lt;/p&gt;
&lt;h3 id=&quot;tail命令语法&quot;&gt;&lt;a href=&quot;#tail命令语法&quot; class=&quot;headerlink&quot; title=&quot;tail命令语法&quot;&gt;&lt;/a&gt;tail命令语法&lt;/h3&gt;&lt;p&gt;tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ]  [-r]  [ File ]&lt;/p&gt;
&lt;p&gt;参数解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-f 该参数用于监视File文件动态增长。&lt;/li&gt;
&lt;li&gt;-c Number 从 Number 字节位置读取指定文件&lt;/li&gt;
&lt;li&gt;-n Number 从 Number 行位置读取指定文件。&lt;/li&gt;
&lt;li&gt;-m Number 从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题。&lt;/li&gt;
&lt;li&gt;-b Number 从 Number 表示的512字节块位置读取指定文件。&lt;/li&gt;
&lt;li&gt;-k Number 从 Number 表示的1KB块位置读取指定文件。&lt;/li&gt;
&lt;li&gt;-r 这个会似的按照现实内容相反的顺序现实，具体见下面例子 &lt;/li&gt;
&lt;li&gt;File 指定操作的目标文件名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述命令中，都涉及到number，假设不指定，默认显示10行。Number前面可使用正负号，表示该偏移从顶部还是从尾部开始计算。这个具体看下面例子。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://fengxiu.club/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hiberate Validator使用教程之自定义约束</title>
    <link href="http://fengxiu.club/archives/76d29d45.html"/>
    <id>http://fengxiu.club/archives/76d29d45.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Hiberate-Validator使用教程之自定义约束&quot;&gt;&lt;a href=&quot;#Hiberate-Validator使用教程之自定义约束&quot; class=&quot;headerlink&quot; title=&quot;Hiberate Validator使用教程之自定义约束&quot;&gt;&lt;/a&gt;Hiberate Validator使用教程之自定义约束&lt;/h1&gt;&lt;!-- 
    1. 创建自定义约束
    2. 自定义错误信息配置
 --&gt;
&lt;p&gt; 前面一篇文章已经讲解了Hibernate Validator的基本使用。虽然校验库本身已经提供了许多的约束，但是不一定能够满足不同功能的需要，这时就需要自定义一些约束，本篇文章主要就是来学习如何自定义约束。&lt;/p&gt;
&lt;h2 id=&quot;简单例子&quot;&gt;&lt;a href=&quot;#简单例子&quot; class=&quot;headerlink&quot; title=&quot;简单例子&quot;&gt;&lt;/a&gt;简单例子&lt;/h2&gt;&lt;p&gt;创建一个简单的自定义约束分为以下三步&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个约束注解&lt;/li&gt;
&lt;li&gt;实现一个约束注解对应的Validator&lt;/li&gt;
&lt;li&gt;定义一个默认的错误信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的这个例子，是用来判断某个String字段是否是全部大小字段或者小写字段。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="教程" scheme="http://fengxiu.club/categories/java/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>maven冲突解决流程</title>
    <link href="http://fengxiu.club/archives/afb2f833.html"/>
    <id>http://fengxiu.club/archives/afb2f833.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;maven冲突解决流程&quot;&gt;&lt;a href=&quot;#maven冲突解决流程&quot; class=&quot;headerlink&quot; title=&quot;maven冲突解决流程&quot;&gt;&lt;/a&gt;maven冲突解决流程&lt;/h1&gt;&lt;!-- 
    mvn dependency 简介
    常见命令介绍
    错误处理
 --&gt;

&lt;p&gt; 当项目比较大且开发维护的时间比较长时，项目的Maven依赖管理也会变得越来越复杂，手动的去排除冲突或者错误已经变得很困难，同时由于开发人员的不规范行为，更一步加深maven的依赖冲突比较多。我也是最近在接手一个已经做了八年项目时才有很大的感悟，之前也没碰过这么久的项目，在自己对maven依赖冲突解决的过程中形成了以下的一些思考或者说技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="构建工具" scheme="http://fengxiu.club/categories/java/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>maven依赖机制简介</title>
    <link href="http://fengxiu.club/archives/d2073860.html"/>
    <id>http://fengxiu.club/archives/d2073860.html</id>
    <published>2021-07-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;maven依赖机制简介&quot;&gt;&lt;a href=&quot;#maven依赖机制简介&quot; class=&quot;headerlink&quot; title=&quot;maven依赖机制简介&quot;&gt;&lt;/a&gt;maven依赖机制简介&lt;/h1&gt;&lt;p&gt;本文主要是对maven官方文档&lt;a href=&quot;https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#introduction-to-the-dependency-mechanism&quot;&gt;Introduction to the Dependency Mechanism&lt;/a&gt;翻译与整理。其中加上了自己的一些理解。&lt;/p&gt;
&lt;p&gt;依赖关系管理是Maven的一个核心特性。管理单个项目的依赖关系很容易。管理由数百个模块组成的多模块项目和应用程序的依赖关系是可能的。Maven在定义、创建和维护具有良好定义的ClassPath路径和Library版本的可复制构建方面有很大帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="构建工具" scheme="http://fengxiu.club/categories/java/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring注解@Autoired和@Resource区别对比</title>
    <link href="http://fengxiu.club/archives/d1a2b8ab.html"/>
    <id>http://fengxiu.club/archives/d1a2b8ab.html</id>
    <published>2020-11-11T06:46:00.000Z</published>
    <updated>2022-03-28T10:05:15.522Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring注解-Autoired和-Resource区别对比&quot;&gt;&lt;a href=&quot;#Spring注解-Autoired和-Resource区别对比&quot; class=&quot;headerlink&quot; title=&quot;Spring注解@Autoired和@Resource区别对比&quot;&gt;&lt;/a&gt;Spring注解@Autoired和@Resource区别对比&lt;/h1&gt;&lt;!-- 
    1. 简单介绍
    2. @Autowired具体使用
    3. @Resouece具体使用
    4. 俩者对比
    5. 扩展介绍，@Primary @Qualifiers
 --&gt;

&lt;p&gt;最近在做项目的时候，由于自己的不细心，导致了一个小错误，在进行bean定义的时候，出现了俩个Bean名字相同但类型不通的Bean，而在进行依赖注入的时候，我选用了@Resource作为注入属性的注解，倒置了项目启动不成功，经过查阅资料，发现是自己对于@Resource注解的使用理解不到位导致的，因此这里有必要对依赖注入使用的注解进行整理分析。&lt;/p&gt;
&lt;p&gt;本文主要对@Resource和@Autowired俩个注解的用法，以及俩者的对比进行整理。并子啊最后对和它们搭配使用的@Qualifiers和@Primary进行整理。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="spring" scheme="http://fengxiu.club/categories/java/spring/"/>
    
    <category term="spring" scheme="http://fengxiu.club/categories/java/spring/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>URL详解</title>
    <link href="http://fengxiu.club/archives/236c7534.html"/>
    <id>http://fengxiu.club/archives/236c7534.html</id>
    <published>2020-09-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;URL详解&quot;&gt;&lt;a href=&quot;#URL详解&quot; class=&quot;headerlink&quot; title=&quot;URL详解&quot;&gt;&lt;/a&gt;URL详解&lt;/h1&gt;&lt;!-- 
    1. 简单介绍
    2. 简单使用
    3. URLConnection简单介绍与使用
    4. URLStreamHandler 简单介绍
    5. 
 --&gt;

&lt;p&gt; 平时看源码中，发现很多开源库都会使用URL这个类，因此有必要对这个类的使用以及原理做一个总结。&lt;/p&gt;
&lt;p&gt;这里先简单介绍一个概念，URL（Uniform Resource Locator）中文名为统一资源定位符，有时也被俗称为网页地址。表示为互联网上的资源，如网页或者FTP地址。&lt;/p&gt;
&lt;p&gt;URL可以分为如下几个部分&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protocol://host:port/path?query#fragment&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="基础" scheme="http://fengxiu.club/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Hibernate Validator 学习与使用</title>
    <link href="http://fengxiu.club/archives/fc06a9d1.html"/>
    <id>http://fengxiu.club/archives/fc06a9d1.html</id>
    <published>2020-09-28T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Hibernate-Validator-学习与使用&quot;&gt;&lt;a href=&quot;#Hibernate-Validator-学习与使用&quot; class=&quot;headerlink&quot; title=&quot;Hibernate Validator 学习与使用&quot;&gt;&lt;/a&gt;Hibernate Validator 学习与使用&lt;/h1&gt;&lt;!-- 
    1.  配置
    2.  简单的demo
    3.  如何声明和校验约束 : 约束集成，级联约束
    4.  自定义约束
    5.  配置约束错误语句
    6.  配置ValueExectuao
    7.  配置Validator
    8.  
 --&gt;
&lt;p&gt;在项目，校验数据是必不可少的一步。因此如果能写出一个好的校验代码，必定能提高项目的鲁棒性。目前我做的项目大部分使用的是SpringBoot，基本上都是在控制器那一层通过注解@Valid等来校验参数，虽然经常使用，但是没有好好的进行整理。所以接下来会写几篇文章，对这一块进行整理。&lt;/p&gt;
&lt;p&gt;大概会整理如下几个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hibernate Validator的用法，&lt;/li&gt;
&lt;li&gt;如何在Spring中使用Hibernate Validator&lt;/li&gt;
&lt;li&gt;介绍如何在Spring MVC中使用。&lt;/li&gt;
&lt;li&gt;分析Spring MVC使用Validator的原理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本篇文章主要是对Hibernate Validator用法进行简单的介绍&lt;/p&gt;
&lt;h2 id=&quot;Hibernate-Validator简介&quot;&gt;&lt;a href=&quot;#Hibernate-Validator简介&quot; class=&quot;headerlink&quot; title=&quot;Hibernate Validator简介&quot;&gt;&lt;/a&gt;Hibernate Validator简介&lt;/h2&gt;&lt;p&gt;验证数据是贯穿所有应用程序层（从应用层到持久层）的常见任务。通常在每一层都实现相同的验证逻辑，这是非常耗时和容易出错的。为了避免这些验证的重复，开发人员经常将验证逻辑直接绑定到域模型中，用验证代码（实际上是关于类本身的元数据）将域类弄乱。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fengxiu/img/master/application-layers.png&quot; alt=&quot;application-layers&quot;&gt;&lt;/p&gt;
&lt;p&gt;Jakarta Bean Validation 2.0——为Entity和方法的验证定义了一个元数据模型和API。默认的元数据源是Annotation，同时也能够通过使用XML覆盖和扩展元数据。API没有绑定到特定的应用层或者programming model.。它与web层或持久层都没有强绑定，可用于服务器端应用程序编程和客户端上应用程序。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fengxiu/img/master/application-layers2.png&quot; alt=&quot;application-layers2&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hibernate Validator和Jakarta Bean Validation的区别：Jakarta Bean Validation是一种规范，Hibernate Validator是对个规范的一种实现。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="教程" scheme="http://fengxiu.club/categories/java/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Validation教程</title>
    <link href="http://fengxiu.club/archives/a61a4fcc.html"/>
    <id>http://fengxiu.club/archives/a61a4fcc.html</id>
    <published>2020-09-13T17:22:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-Validation教程&quot;&gt;&lt;a href=&quot;#Spring-Validation教程&quot; class=&quot;headerlink&quot; title=&quot;Spring Validation教程&quot;&gt;&lt;/a&gt;Spring Validation教程&lt;/h1&gt;&lt;!-- 
1. 阐述validation DataBinder的关系
2. BeanWrapper
3. PropertyEditorSupport  PropertyEditor 解析属性，这个符合JavaBean标准
   core.convert 提供通用类型转换的能力和format提供UI 属性值的转换能力
   org.springframework.beans.propertyeditors 这个包下面提供了默认的字符串转换成对象

   字符串转成对象，通过java.beans.PropertyEditor接口来实现，Spring遵循了这套标准，然后进行转换。
4. spring自身提供了一个Validator 适配器

1. 通过实现Validator接口验证bean

--&gt;

&lt;p&gt;前面已经有俩篇文章介绍了Hibernate Validator的使用，而Spring Validation就是对Hibernate Validator又一层封装，方便在Spring中使用。这里我们先介绍Spring Validation的基本用法，包含在Service层中使用和在Controller中使用。&lt;/p&gt;
&lt;p&gt;在Spring中有俩种校验Bean的方式，一种是通过实现org.springframework.validation.Validator接口，然后在代码中调用这个类，另外一种是按照Bean Validation方式来进行校验，即通过注解的方式，这一种和前面介绍的使用Hibernate Validator来进行校验基本一致。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="教程" scheme="http://fengxiu.club/categories/java/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何从Jar包中加载class</title>
    <link href="http://fengxiu.club/archives/7e5ec6ca.html"/>
    <id>http://fengxiu.club/archives/7e5ec6ca.html</id>
    <published>2020-09-13T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;如何从Jar包中加载class&quot;&gt;&lt;a href=&quot;#如何从Jar包中加载class&quot; class=&quot;headerlink&quot; title=&quot;如何从Jar包中加载class&quot;&gt;&lt;/a&gt;如何从Jar包中加载class&lt;/h1&gt;&lt;!--  
    1. 简单介绍
    2. 说明URLClassPath 和URLClassPath.Loader之间的关系
    3. 整个加载流程
    4. 函数分析
--&gt;

&lt;p&gt;之前在看java类加载机制的时候，就在想，JVM是如何在Jar包中找到某个具体的Class文件，如果是把Jar包解压到一个指定的文件中，那我还能理解，他是先解压然后在去解压后的文件中查找有没有具体的文件，但事实上，jvm在运行java程序时候，并没有将jar包解压。所以就比较好奇jvm是如何获取到具体的class文件。本篇文章主要对其进行探究。&lt;/p&gt;
&lt;p&gt;这里就不在叙述类加载机制，直接定位到具体加载Class文件资源的函数，代码如下：&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="基础" scheme="http://fengxiu.club/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>MapStruct使用教程一</title>
    <link href="http://fengxiu.club/archives/bb156b86.html"/>
    <id>http://fengxiu.club/archives/bb156b86.html</id>
    <published>2020-09-13T10:09:53.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;MapStruct使用教程一&quot;&gt;&lt;a href=&quot;#MapStruct使用教程一&quot; class=&quot;headerlink&quot; title=&quot;MapStruct使用教程一&quot;&gt;&lt;/a&gt;MapStruct使用教程一&lt;/h1&gt;&lt;!-- 
    1. 是什么
    2. 相对于其它框架的优点
    3. 简单使用
       1. maven配置
       2. 简单demo
       3. 和lombok一起使用
       4. 定义mapper
       5. 获取mapper
 --&gt;
&lt;p&gt;在日常开发中，我们会定义多种不通的Javabean，比如DTO（Data Transfer Object：数据传输对象），DO（Data Object：数据库映射对象，与数据库一一映射），VO（View Object：显示层对象，通常是 Web 向模板渲染引擎层传输的对象）等等这些对象。在这些对象与对象之间转换通常是调对象的set和get方法进行复制，这种转换通常也是很无聊的操作，因此就需要有一个专门的工具来解决Javabean之间的转换问题，让我们从这种无聊的转换操作中解放出来。&lt;/p&gt;
&lt;p&gt;MapStruct就是这样一个属性映射工具，用于解决上述对象之间转换问题。&lt;a href=&quot;https://mapstruct.org/&quot;&gt;MapStruct官网&lt;/a&gt;。官网给出的MapStruct定义：MapStruct是一个Java注释处理器，用于生成类型安全的bean映射类。&lt;/p&gt;
&lt;p&gt;我们要做的就是定义一个映射器接口，声明任何必需的映射方法。在编译的过程中，MapStruct会生成此接口的实现。该实现使用纯java方法调用的源对象和目标对象之间的映射。对比手写这些映射方法，MapStruct通过自动生成代码完成繁琐和手写容易出错的代码逻辑从而节省编码时间。遵循配置方法上的约定，MapStruct使用合理的默认值，但在配置或实现特殊行为时不加理会。&lt;/p&gt;
&lt;p&gt;与动态映射框架相比，MapStruct具有以下优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;速度快：使用普通的方法代替反射&lt;/li&gt;
&lt;li&gt;编译时类型安全性 : 只能映射彼此的对象和属性，不会将商品实体意外映射到用户DTO等&lt;/li&gt;
&lt;li&gt;在build时期有明确的错误报告，主要有下面俩种&lt;ol&gt;
&lt;li&gt;映射不完整，目标对象中有些属性没有被映射&lt;/li&gt;
&lt;li&gt;映射不正确，找不到一个合适的映射方法或者类型转换方法</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="教程" scheme="http://fengxiu.club/categories/java/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>MapStruct使用教程二</title>
    <link href="http://fengxiu.club/archives/8095452f.html"/>
    <id>http://fengxiu.club/archives/8095452f.html</id>
    <published>2020-09-13T01:08:00.000Z</published>
    <updated>2022-03-28T10:05:15.526Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;MapStruct使用教程二&quot;&gt;&lt;a href=&quot;#MapStruct使用教程二&quot; class=&quot;headerlink&quot; title=&quot;MapStruct使用教程二&quot;&gt;&lt;/a&gt;MapStruct使用教程二&lt;/h1&gt;&lt;!--  
1. 数据类型转换
2. 转换集合类型
3. 复用配置
 --&gt;

&lt;p&gt; 上一篇文章已经见过定义mapper和检索mapper等内容，这一节继续探索MapStruct的使用，主要有以下三个部分，数据类型转换，重复使用Mapping配置，高级技巧内容。&lt;/p&gt;
&lt;h2 id=&quot;数据类型转换&quot;&gt;&lt;a href=&quot;#数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;数据类型转换&quot;&gt;&lt;/a&gt;数据类型转换&lt;/h2&gt;&lt;p&gt; source和target对象在进行属性映射时，并不一定总是类型相同的，比如int类型映射成Long类型。或者不通的类型之间映射。下面将介绍MapStruct是如何处理数据类型转换的。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://fengxiu.club/categories/java/"/>
    
    <category term="教程" scheme="http://fengxiu.club/categories/java/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="DDD" scheme="http://fengxiu.club/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>github action自动部署hexo</title>
    <link href="http://fengxiu.club/archives/250adeef.html"/>
    <id>http://fengxiu.club/archives/250adeef.html</id>
    <published>2020-07-18T21:44:59.000Z</published>
    <updated>2022-03-28T10:05:15.510Z</updated>
    
    
    <summary type="html">&lt;!-- 
    1. 原因，简单介绍
    2. 生成ssh-key
    3. 开始配置
    4. 如何能够自动触发action
 --&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/features/actions&quot;&gt;Github Actions&lt;/a&gt;是GitHub官方CI工具,与GitHub无缝集成。之前博客使用TravisCI实现的自动部署，现在转用GitHub Actions部署，本文记录部署流程。&lt;br&gt;如果你对次不怎么熟悉，可以参考阮一峰大神写的一篇入门文章，里面对基本的使用进行了介绍，&lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html&quot;&gt;GitHub Actions 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面简单介绍下，github actions中用的一些术语&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。&lt;/li&gt;
&lt;li&gt;job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。&lt;/li&gt;
&lt;li&gt;step（步骤）：每个 job 由多个 step 构成，一步步完成。&lt;/li&gt;
&lt;li&gt;action （动作）：每个 step 可以依次执行一个或多个命令（action）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来是操作步骤&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="http://fengxiu.club/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://fengxiu.club/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>字体</title>
    <link href="http://fengxiu.club/archives/5a8a6c8d.html"/>
    <id>http://fengxiu.club/archives/5a8a6c8d.html</id>
    <published>2020-03-31T04:30:35.000Z</published>
    <updated>2022-03-28T10:05:15.530Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;!-- TODO添加字体 --&gt;
&lt;p&gt;TTF（TrueType Font）是Apple公司和Microsoft公司共同推出的字体文件格式，随着windows的流行，已经变成最常用的一种字体文件表示方式。&lt;br&gt;而OTF（OpenType Font）是 TTF 的升级版，而</summary>
        
      
    
    
    
    <category term="tex" scheme="http://fengxiu.club/categories/tex/"/>
    
    
    <category term="字体" scheme="http://fengxiu.club/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
</feed>
