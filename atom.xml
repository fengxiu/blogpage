<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫秀学习日志</title>
  <icon>http://fengxiu.club/icon.png</icon>
  <subtitle>枫秀学习日志</subtitle>
  <link href="http://fengxiu.club/atom.xml" rel="self"/>
  
  <link href="http://fengxiu.club/"/>
  <updated>2022-04-17T14:39:43.223Z</updated>
  <id>http://fengxiu.club/</id>
  
  <author>
    <name>枫秀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>外观模式</title>
    <link href="http://fengxiu.club/archives/f7de8aa8.html"/>
    <id>http://fengxiu.club/archives/f7de8aa8.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-04-17T14:39:43.223Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h1&gt;&lt;p&gt;外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。&lt;/p&gt;
&lt;p&gt;最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://fengxiu.club/archives/f5c535ea.html"/>
    <id>http://fengxiu.club/archives/f5c535ea.html</id>
    <published>2021-08-28T10:09:53.000Z</published>
    <updated>2022-04-17T14:39:43.223Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;p&gt;适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。&lt;/p&gt;
&lt;p&gt;在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fengxiu/img/master/problem-zh-2x.png&quot; alt=&quot;problem-zh-2x&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://fengxiu.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯TEG面经：java实习岗</title>
    <link href="http://fengxiu.club/archives/52bb366.html"/>
    <id>http://fengxiu.club/archives/52bb366.html</id>
    <published>2019-04-02T10:49:22.000Z</published>
    <updated>2022-04-17T14:39:43.223Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;下面记录的是我面腾讯TEG事业群的经历&lt;/p&gt;
&lt;h2 id=&quot;腾讯一面-2019年03月13日&quot;&gt;&lt;a href=&quot;#腾讯一面-2019年03月13日&quot; class=&quot;headerlink&quot; title=&quot;腾讯一面 2019年03月13日&quot;&gt;&lt;/a&gt;腾讯一面</summary>
        
      
    
    
    
    <category term="面试" scheme="http://fengxiu.club/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里春招实习面经：java开发</title>
    <link href="http://fengxiu.club/archives/8650cc91.html"/>
    <id>http://fengxiu.club/archives/8650cc91.html</id>
    <published>2019-04-02T11:27:29.000Z</published>
    <updated>2022-04-17T14:39:43.223Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;先说一下，你们可能看到我的面经也会觉得很惊奇，为什么其他面经里面出现的问题，我这里几乎都没出现，而且面试流程也走的这么快。下面就看一下我的阿里春招面试奇葩之旅。&lt;/p&gt;
&lt;h2 id=&quot;阿里一面-2019年03月28日&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="面试" scheme="http://fengxiu.club/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域资源共享(CORS)</title>
    <link href="http://fengxiu.club/archives/f1718313.html"/>
    <id>http://fengxiu.club/archives/f1718313.html</id>
    <published>2019-04-29T14:54:01.000Z</published>
    <updated>2022-04-17T14:39:43.223Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;跨域资源共享(CORS)是一种机制，它使用额外的HTTP头来告诉浏览器让运行在一个origin(domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP请求。&lt;/p&gt;
&lt;p&gt;比如，站点&lt;a href=&quot;&quot;&gt;http://domain-a.com&lt;/a&gt;的某HTML页面通过&lt;code&gt;img&lt;/code&gt;的src请求&lt;a href=&quot;&quot;&gt;http://domain-b.com/image.jpg&lt;/a&gt;。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。&lt;/p&gt;
&lt;p&gt;出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://fengxiu.club/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
    <category term="跨域资源共享" scheme="http://fengxiu.club/tags/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    
    <category term="cors" scheme="http://fengxiu.club/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>配置虚拟主机</title>
    <link href="http://fengxiu.club/archives/74b15736.html"/>
    <id>http://fengxiu.club/archives/74b15736.html</id>
    <published>2019-03-09T13:21:00.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;配置虚拟主机&quot;&gt;&lt;a href=&quot;#配置虚拟主机&quot; class=&quot;headerlink&quot; title=&quot;配置虚拟主机&quot;&gt;&lt;/a&gt;配置虚拟主机&lt;/h1&gt;&lt;p&gt;本节主要讲解如果使用&lt;strong&gt;nginx配置多个虚拟主机&lt;/strong&gt;,也就是我们通常说的配置域名.接下来我们配置两个域名&lt;code&gt;a.zhangke.com，b.zhangke.com&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://fengxiu.club/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://fengxiu.club/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>latex之插入图片</title>
    <link href="http://fengxiu.club/archives/cd65b57.html"/>
    <id>http://fengxiu.club/archives/cd65b57.html</id>
    <published>2019-12-26T09:08:11.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;!--  TODO:添加latex图片使用   </summary>
        
      
    
    
    
    <category term="tex" scheme="http://fengxiu.club/categories/tex/"/>
    
    
  </entry>
  
  <entry>
    <title>latex之列表使用</title>
    <link href="http://fengxiu.club/archives/dd2855a.html"/>
    <id>http://fengxiu.club/archives/dd2855a.html</id>
    <published>2019-12-26T09:08:11.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;p&gt;列表就是将所要表达的内容分为若干个条目并按一定的顺序排列，达到简明、直观的效果。在论文的写作中会经常使用到列表。LaTeX 中常见的列表环境有 enumerate、itemize 和description。这三种列表环境的主要区别是列表项标签的不同。&lt;/p&gt;</summary>
    
    
    
    <category term="tex" scheme="http://fengxiu.club/categories/tex/"/>
    
    
  </entry>
  
  <entry>
    <title>字体</title>
    <link href="http://fengxiu.club/archives/5a8a6c8d.html"/>
    <id>http://fengxiu.club/archives/5a8a6c8d.html</id>
    <published>2020-03-31T04:30:35.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;!-- TODO添加字体 --&gt;
&lt;p&gt;TTF（TrueType Font）是Apple公司和Microsoft公司共同推出的字体文件格式，随着windows的流行，已经变成最常用的一种字体文件表示方式。&lt;br&gt;而OTF（OpenType Font）是 TTF 的升级版，而</summary>
        
      
    
    
    
    <category term="tex" scheme="http://fengxiu.club/categories/tex/"/>
    
    
    <category term="字体" scheme="http://fengxiu.club/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash</title>
    <link href="http://fengxiu.club/archives/5cd14851.html"/>
    <id>http://fengxiu.club/archives/5cd14851.html</id>
    <published>2019-03-11T02:40:00.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;一致性hash&quot;&gt;&lt;a href=&quot;#一致性hash&quot; class=&quot;headerlink&quot; title=&quot;一致性hash&quot;&gt;&lt;/a&gt;一致性hash&lt;/h1&gt;&lt;p&gt;首先我们通过一个例子看看普通的hash算法在应用中有哪些不足，最后来讲解本文重点要讲解的问题，一致性hash。&lt;/p&gt;
&lt;p&gt;我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://fengxiu.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="hash" scheme="http://fengxiu.club/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>数据库和缓存双写一致性方案简介</title>
    <link href="http://fengxiu.club/archives/dc527cae.html"/>
    <id>http://fengxiu.club/archives/dc527cae.html</id>
    <published>2019-04-03T16:45:55.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章主要先介绍几种数据库和缓存双写一致性的方案并分析其中的优缺点，最后讲解一下网上经常出现的一些关于这方面的名词。&lt;/p&gt;
&lt;h2 id=&quot;更新策略&quot;&gt;&lt;a href=&quot;#更新策略&quot; class=&quot;headerlink&quot; title=&quot;更新策略&quot;&gt;&lt;/a&gt;更新策略&lt;/h2&gt;&lt;p&gt;首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，都是按照下图的流程来进行业务操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/o_getkeyflow.png&quot; alt=&quot;o_getkeyflow&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://fengxiu.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="数据库" scheme="http://fengxiu.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="缓存" scheme="http://fengxiu.club/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="一致性方案" scheme="http://fengxiu.club/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>IO模型：阻塞、非阻塞、同步和异步之间的区别</title>
    <link href="http://fengxiu.club/archives/aeafbee0.html"/>
    <id>http://fengxiu.club/archives/aeafbee0.html</id>
    <published>2019-03-22T23:04:13.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在Unix系统中，主要有以下5种IO模型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式IO&lt;/li&gt;
&lt;li&gt;非阻塞式IO&lt;/li&gt;
&lt;li&gt;IO复用&lt;/li&gt;
&lt;li&gt;信号量式驱动IO&lt;/li&gt;
&lt;li&gt;异步IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章主要是想弄明白阻塞和非阻塞、同步与异步之间的区别，因此信号量式驱动IO本篇文章不会涉及，如果以后我用到的话，会在来补充。&lt;/p&gt;
&lt;p&gt;对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;等待数据准备 (Waiting for the data to be ready)&lt;/li&gt;
&lt;li&gt;将数据从内核拷贝到进程中 (Copying the data from the kernel&lt;br&gt; to the process)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。下面首先介绍每种IO模型，然后在来总结他们之间的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://fengxiu.club/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://fengxiu.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>cpu cache结构和缓存一致性(MESI协议)</title>
    <link href="http://fengxiu.club/archives/257afb79.html"/>
    <id>http://fengxiu.club/archives/257afb79.html</id>
    <published>2019-04-02T09:42:46.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;cache简介&quot;&gt;&lt;a href=&quot;#cache简介&quot; class=&quot;headerlink&quot; title=&quot;cache简介&quot;&gt;&lt;/a&gt;cache简介&lt;/h2&gt;&lt;p&gt;CPU缓存（Cache Memory）是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。高速缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://fengxiu.club/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="cache" scheme="http://fengxiu.club/tags/cache/"/>
    
    <category term="缓存一致性" scheme="http://fengxiu.club/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://fengxiu.club/archives/f79e4123.html"/>
    <id>http://fengxiu.club/archives/f79e4123.html</id>
    <published>2018-09-21T14:42:00.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h1&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;虚拟内存是什么、可以用来做什么&lt;/li&gt;
&lt;li&gt;基本概念介绍&lt;/li&gt;
&lt;li&gt;虚拟内存作为缓存的工具&lt;/li&gt;
&lt;li&gt;虚拟内存作为内存管理的工具&lt;/li&gt;
&lt;li&gt;虚拟内存作为内存保护的工具&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-虚拟内存是什么、功能是什么&quot;&gt;&lt;a href=&quot;#1-虚拟内存是什么、功能是什么&quot; class=&quot;headerlink&quot; title=&quot;1. 虚拟内存是什么、功能是什么&quot;&gt;&lt;/a&gt;1. 虚拟内存是什么、功能是什么&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;虚拟内存是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存&lt;/strong&gt;是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。&lt;/p&gt;
&lt;p&gt;下面是《深入立即操作系统》给出的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。&lt;/p&gt;
&lt;p&gt;虚拟内存功能是什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。&lt;/li&gt;
&lt;li&gt;它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/li&gt;
&lt;li&gt;它保护了每个进程的地址空间不被其他进程破坏。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://fengxiu.club/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://fengxiu.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="http://fengxiu.club/archives/6ebbfb41.html"/>
    <id>http://fengxiu.club/archives/6ebbfb41.html</id>
    <published>2019-06-11T14:49:58.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文翻译自:&lt;a href=&quot;http://www.linuxjournal.com/article/6345&quot;&gt;Zero Copy I: User-Mode Perspective&lt;/a&gt;&lt;br&gt;本文解释了Linux的零拷贝作用是什么，为什么它非常有用和在哪些地方可以使用该功能。&lt;/p&gt;
&lt;p&gt;到目前为止，几乎每个人都听说过在Linux下的所谓的零拷贝功能，但我经常遇到对这个主题没有完全理解的人。 正因为如此，我决定写一些文章，深入探讨这件事，希望揭开这个有用的功能。 在本文中，我们从用户应用程序的角度看待零拷贝，因此故意省略了内核级别的详细信息。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://fengxiu.club/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://fengxiu.club/tags/linux/"/>
    
    <category term="零拷贝" scheme="http://fengxiu.club/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池大小设置</title>
    <link href="http://fengxiu.club/archives/8551d0c1.html"/>
    <id>http://fengxiu.club/archives/8551d0c1.html</id>
    <published>2019-08-28T10:09:53.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;p&gt;翻译自&lt;a href=&quot;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&quot;&gt;About Pool Sizing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开发人员在配置数据库连接池的时候，经常会犯一些错误。在配置数据库连接池时，需要理解一些可能违反直觉的原则。&lt;br&gt;因此本篇文章主要介绍这些原则。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://fengxiu.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="连接池" scheme="http://fengxiu.club/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>LVS、Nginx及HAProxy工作原理简介</title>
    <link href="http://fengxiu.club/archives/3c2eb649.html"/>
    <id>http://fengxiu.club/archives/3c2eb649.html</id>
    <published>2019-07-20T12:22:32.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;当前大多数的互联网系统都使用了服务器集群技术，集群是将相同服务部署在多台服务器上构成一个集群整体对外提供服务，这些集群可以是 Web 应用服务器集群，也可以是数据库服务器集群，还可以是分布式缓存服务器集群等等。&lt;br&gt;&lt;img src=&quot;/images/640.webp&quot; alt=&quot;640&quot;&gt;&lt;br&gt;在实际应用中，在 Web服务器集群之前总会有一台负载均衡服务器，负载均衡设备的任务就是作为Web 服务器流量的入口，挑选最合适的一台 Web 服务器，将客户端的请求转发给它处理，实现客户端到真实服务端的透明转发。&lt;/p&gt;
&lt;p&gt;最近几年很火的「云计算」以及分布式架构，本质上也是将后端服务器作为计算资源、存储资源，由某台管理服务器封装成一个服务对外提供，客户端不需要关心真正提供服务的是哪台机器，在它看来，就好像它面对的是一台拥有近乎无限能力的服务器，而本质上，真正提供服务的，是后端的集群。&lt;/p&gt;</summary>
    
    
    
    <category term="架构" scheme="http://fengxiu.club/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="代理" scheme="http://fengxiu.club/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="负载均衡" scheme="http://fengxiu.club/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Zuul2：Netflix通往异步、非阻塞系统之路</title>
    <link href="http://fengxiu.club/archives/ad8701ca.html"/>
    <id>http://fengxiu.club/archives/ad8701ca.html</id>
    <published>2019-07-12T16:02:36.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c&quot;&gt;Zuul 2 : The Netflix Journey to Asynchronous, Non-Blocking Systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面在学习Spring Cloud中，了解到zuul这个应用网关，但是由于当时看到的是zuul1，使用的Servlet方式实现，所以整体性能很低。不过Netflix实际上升级了zuul，使用了netty来改造网关，也就是现在网关底层使用的是异步非阻塞的架构。下面我们就一起来拜读下他们的改造路程。&lt;br&gt;翻译如下：&lt;/p&gt;
&lt;p&gt;我们最近对我们的云网关Zuul进行了重大架构改造。Zuul2的功能与其前任相同 - 作为Netflix服务器基础设施的前门，处理来自全球所有Netflix用户的流量。它还可以路由请求，支持开发人员的测试和调试，深入了解我们的整体服务运行状况，保护Netflix免受攻击，并在AWS区域出现问题时将流量引导至其他云区域。 Zuul 2和原始版本之间的主要架构差异是Zuul2使用Netty在异步和非阻塞框架上运行。在过去几个月投入生产之后，主要优势（我们在开始这项工作时所期望的一个优势）是它为设备和Web浏览器提供了在Netflix规模上持久连接回Netflix的能力。拥有超过8300万会员，每个会员都有多个连接设备，这是一个巨大的挑战。通过与我们的云基础架构保持持久连接，我们可以实现许多有趣的产品功能和创新，减少整体设备请求，提高设备性能，更好地理解和调试客户体验。&lt;/p&gt;
&lt;p&gt;我们还希望Zuul2在延迟，吞吐量和成本方面提供弹性优势和性能改进。但正如您将在本文中了解到的那样，我们的愿望与结果不同。&lt;/p&gt;</summary>
    
    
    
    <category term="架构" scheme="http://fengxiu.club/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="zuul2" scheme="http://fengxiu.club/tags/zuul2/"/>
    
  </entry>
  
  <entry>
    <title>numpy之aixs</title>
    <link href="http://fengxiu.club/archives/b40cb3ed.html"/>
    <id>http://fengxiu.club/archives/b40cb3ed.html</id>
    <published>2019-04-16T22:05:26.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在看机器学习方面内容，所以需要写一些代码来跑机器学习中一些简单的算法。很多算法都用到numpy这个库。但是对立面&lt;code&gt;axis&lt;/code&gt;轴这个名词一直不懂。本篇文章就是来解释这个名词是什么意思。&lt;/p&gt;
&lt;p&gt;要想理解这个名词，我们先看一些例子，看懂例子之后，这个名词就比较好理解。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://fengxiu.club/categories/python/"/>
    
    <category term="numpy" scheme="http://fengxiu.club/categories/python/numpy/"/>
    
    
    <category term="aixs" scheme="http://fengxiu.club/tags/aixs/"/>
    
    <category term="轴" scheme="http://fengxiu.club/tags/%E8%BD%B4/"/>
    
    <category term="机器学习" scheme="http://fengxiu.club/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>管理git仓库内的子仓库</title>
    <link href="http://fengxiu.club/archives/5d8f9bd8.html"/>
    <id>http://fengxiu.club/archives/5d8f9bd8.html</id>
    <published>2019-04-13T20:12:23.000Z</published>
    <updated>2022-04-17T14:39:43.219Z</updated>
    
    
    <summary type="html">&lt;p&gt;我在使用hexo构建自己的博客时遇到过这样的一种情况。使用&lt;code&gt;hexo init&lt;/code&gt;命令创建一个静态网页目录，然后使用git来管理这个目录。如果这时需要替换themes，一般都是克隆主题对应的的仓库到themes目录下面，这时就会出现一个仓库里面包含另外一个子仓库，在git里面，称这为子模块。但是我们改了主题的配置文件，去提交，会返现主题对应的目录是空的。&lt;/p&gt;
&lt;p&gt;首先有一种最简单的方法，就是讲子模块下面的&lt;code&gt;.git&lt;/code&gt;目录给删除，那么这个仓库就是一个普通的目录，但是这个对以后升级不方便。&lt;/p&gt;
&lt;p&gt;下面我们通过实例来讲解如何优雅的解决这个问题。&lt;/p&gt;
&lt;p&gt;我创建的目录结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Xnip2019-04-14_00-30-14.jpg&quot; alt=&quot;Xnip2019-04-14_00-30-14&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://fengxiu.club/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="git" scheme="http://fengxiu.club/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
    
    <category term="git" scheme="http://fengxiu.club/tags/git/"/>
    
    <category term="子模块" scheme="http://fengxiu.club/tags/%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
</feed>
